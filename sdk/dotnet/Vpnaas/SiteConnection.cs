// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Linq;

namespace Pulumi.Openstack.Vpnaas {

	public sealed class SiteConnectionArgsDpd : Pulumi.IIOProtobuf {
		public Pulumi.IO<string> Action { get; set; }
		public Pulumi.IO<int> Interval { get; set; }
		public Pulumi.IO<int> Timeout { get; set; }

		public Pulumi.IO<Google.Protobuf.WellKnownTypes.Value> ToProtobuf() {
			return Pulumi.Protobuf.ToProtobuf(
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("action", Protobuf.ToProtobuf(Action)),
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("interval", Protobuf.ToProtobuf(Interval)),
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("timeout", Protobuf.ToProtobuf(Timeout)));
		} // ToProtobuf

	} // SiteConnectionArgsDpd

	public sealed class SiteConnectionDpd : Pulumi.IIOProtobuf {
		public Pulumi.IO<string> Action { get; set; }
		public Pulumi.IO<int> Interval { get; set; }
		public Pulumi.IO<int> Timeout { get; set; }

		public Pulumi.IO<Google.Protobuf.WellKnownTypes.Value> ToProtobuf() {
			return Pulumi.Protobuf.ToProtobuf(
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("action", Protobuf.ToProtobuf(Action)),
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("interval", Protobuf.ToProtobuf(Interval)),
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("timeout", Protobuf.ToProtobuf(Timeout)));
		} // ToProtobuf

		public static SiteConnectionDpd FromProtobuf(Google.Protobuf.WellKnownTypes.Value value) {
			var obj = value.StructValue;
			return new SiteConnectionDpd() {
				Action = Protobuf.ToString(obj.Fields["action"]),
				Interval = Protobuf.ToInt(obj.Fields["interval"]),
				Timeout = Protobuf.ToInt(obj.Fields["timeout"]),
			};
		} // FromProtobuf

	} // SiteConnectionDpd

	/// <summary>
	/// The set of arguments for constructing a SiteConnection resource.
	/// </summary>
	public struct SiteConnectionArgs {
		/// <summary>
		/// The administrative state of the resource. Can either be up(true) or down(false).
		/// Changing this updates the administrative state of the existing connection.
		/// </summary>
		public Pulumi.IO<bool> AdminStateUp { get; set; }

		/// <summary>
		/// The human-readable description for the connection.
		/// Changing this updates the description of the existing connection.
		/// </summary>
		public Pulumi.IO<string> Description { get; set; }

		/// <summary>
		/// A dictionary with dead peer detection (DPD) protocol controls.
		/// - `action` - (Optional) The dead peer detection (DPD) action.
		/// A valid value is clear, hold, restart, disabled, or restart-by-peer.
		/// Default value is hold.
		/// </summary>
		public Pulumi.IO<Pulumi.IO<SiteConnectionArgsDpd>[]> Dpds { get; set; }

		/// <summary>
		/// The ID of the IKE policy. Changing this creates a new connection.
		/// </summary>
		public Pulumi.IO<string> IkepolicyId { get; set; }

		/// <summary>
		/// A valid value is response-only or bi-directional. Default is bi-directional.
		/// </summary>
		public Pulumi.IO<string> Initiator { get; set; }

		/// <summary>
		/// The ID of the IPsec policy. Changing this creates a new connection.
		/// </summary>
		public Pulumi.IO<string> IpsecpolicyId { get; set; }

		/// <summary>
		/// The ID for the endpoint group that contains private subnets for the local side of the connection.
		/// You must specify this parameter with the peer_ep_group_id parameter unless
		/// in backward- compatible mode where peer_cidrs is provided with a subnet_id for the VPN service.
		/// Changing this updates the existing connection.
		/// </summary>
		public Pulumi.IO<string> LocalEpGroupId { get; set; }

		/// <summary>
		/// An ID to be used instead of the external IP address for a virtual router used in traffic between instances on different networks in east-west traffic.
		/// Most often, local ID would be domain name, email address, etc.
		/// If this is not configured then the external IP address will be used as the ID.
		/// </summary>
		public Pulumi.IO<string> LocalId { get; set; }

		/// <summary>
		/// The maximum transmission unit (MTU) value to address fragmentation.
		/// Minimum value is 68 for IPv4, and 1280 for IPv6.
		/// </summary>
		public Pulumi.IO<int> Mtu { get; set; }

		/// <summary>
		/// The name of the connection. Changing this updates the name of
		/// the existing connection.
		/// </summary>
		public Pulumi.IO<string> Name { get; set; }

		/// <summary>
		/// The peer gateway public IPv4 or IPv6 address or FQDN.
		/// </summary>
		public Pulumi.IO<string> PeerAddress { get; set; }

		/// <summary>
		/// Unique list of valid peer private CIDRs in the form < net_address > / < prefix > .
		/// </summary>
		public Pulumi.IO<Pulumi.IO<string>[]> PeerCidrs { get; set; }

		/// <summary>
		/// The ID for the endpoint group that contains private CIDRs in the form < net_address > / < prefix > for the peer side of the connection.
		/// You must specify this parameter with the local_ep_group_id parameter unless in backward-compatible mode
		/// where peer_cidrs is provided with a subnet_id for the VPN service.
		/// </summary>
		public Pulumi.IO<string> PeerEpGroupId { get; set; }

		/// <summary>
		/// The peer router identity for authentication. A valid value is an IPv4 address, IPv6 address, e-mail address, key ID, or FQDN.
		/// Typically, this value matches the peer_address value.
		/// Changing this updates the existing policy.
		/// </summary>
		public Pulumi.IO<string> PeerId { get; set; }

		/// <summary>
		/// The pre-shared key. A valid value is any string.
		/// </summary>
		public Pulumi.IO<string> Psk { get; set; }

		/// <summary>
		/// The region in which to obtain the V2 Networking client.
		/// A Networking client is needed to create an IPSec site connection. If omitted, the
		/// `region` argument of the provider is used. Changing this creates a new
		/// site connection.
		/// </summary>
		public Pulumi.IO<string> Region { get; set; }

		/// <summary>
		/// The owner of the connection. Required if admin wants to
		/// create a connection for another project. Changing this creates a new connection.
		/// </summary>
		public Pulumi.IO<string> TenantId { get; set; }

		/// <summary>
		/// Map of additional options.
		/// </summary>
		public Pulumi.IO<System.Collections.Generic.Dictionary<string, string>> ValueSpecs { get; set; }

		/// <summary>
		/// The ID of the VPN service. Changing this creates a new connection.
		/// </summary>
		public Pulumi.IO<string> VpnserviceId { get; set; }

	} // SiteConnectionArgs

	/// <summary>
	/// Manages a V2 Neutron IPSec site connection resource within OpenStack.
	/// </summary>
	public class SiteConnection : Pulumi.CustomResource {
		/// <summary>
		/// The administrative state of the resource. Can either be up(true) or down(false).
		/// Changing this updates the administrative state of the existing connection.
		/// </summary>
		public Pulumi.IO<bool> AdminStateUp { get; set; }

		/// <summary>
		/// The human-readable description for the connection.
		/// Changing this updates the description of the existing connection.
		/// </summary>
		public Pulumi.IO<string> Description { get; set; }

		/// <summary>
		/// A dictionary with dead peer detection (DPD) protocol controls.
		/// - `action` - (Optional) The dead peer detection (DPD) action.
		/// A valid value is clear, hold, restart, disabled, or restart-by-peer.
		/// Default value is hold.
		/// </summary>
		public Pulumi.IO<SiteConnectionDpd[]> Dpds { get; set; }

		/// <summary>
		/// The ID of the IKE policy. Changing this creates a new connection.
		/// </summary>
		public Pulumi.IO<string> IkepolicyId { get; set; }

		/// <summary>
		/// A valid value is response-only or bi-directional. Default is bi-directional.
		/// </summary>
		public Pulumi.IO<string> Initiator { get; set; }

		/// <summary>
		/// The ID of the IPsec policy. Changing this creates a new connection.
		/// </summary>
		public Pulumi.IO<string> IpsecpolicyId { get; set; }

		/// <summary>
		/// The ID for the endpoint group that contains private subnets for the local side of the connection.
		/// You must specify this parameter with the peer_ep_group_id parameter unless
		/// in backward- compatible mode where peer_cidrs is provided with a subnet_id for the VPN service.
		/// Changing this updates the existing connection.
		/// </summary>
		public Pulumi.IO<string> LocalEpGroupId { get; set; }

		/// <summary>
		/// An ID to be used instead of the external IP address for a virtual router used in traffic between instances on different networks in east-west traffic.
		/// Most often, local ID would be domain name, email address, etc.
		/// If this is not configured then the external IP address will be used as the ID.
		/// </summary>
		public Pulumi.IO<string> LocalId { get; set; }

		/// <summary>
		/// The maximum transmission unit (MTU) value to address fragmentation.
		/// Minimum value is 68 for IPv4, and 1280 for IPv6.
		/// </summary>
		public Pulumi.IO<int> Mtu { get; set; }

		/// <summary>
		/// The name of the connection. Changing this updates the name of
		/// the existing connection.
		/// </summary>
		public Pulumi.IO<string> Name { get; set; }

		/// <summary>
		/// The peer gateway public IPv4 or IPv6 address or FQDN.
		/// </summary>
		public Pulumi.IO<string> PeerAddress { get; set; }

		/// <summary>
		/// Unique list of valid peer private CIDRs in the form < net_address > / < prefix > .
		/// </summary>
		public Pulumi.IO<string[]> PeerCidrs { get; set; }

		/// <summary>
		/// The ID for the endpoint group that contains private CIDRs in the form < net_address > / < prefix > for the peer side of the connection.
		/// You must specify this parameter with the local_ep_group_id parameter unless in backward-compatible mode
		/// where peer_cidrs is provided with a subnet_id for the VPN service.
		/// </summary>
		public Pulumi.IO<string> PeerEpGroupId { get; set; }

		/// <summary>
		/// The peer router identity for authentication. A valid value is an IPv4 address, IPv6 address, e-mail address, key ID, or FQDN.
		/// Typically, this value matches the peer_address value.
		/// Changing this updates the existing policy.
		/// </summary>
		public Pulumi.IO<string> PeerId { get; set; }

		/// <summary>
		/// The pre-shared key. A valid value is any string.
		/// </summary>
		public Pulumi.IO<string> Psk { get; set; }

		/// <summary>
		/// The region in which to obtain the V2 Networking client.
		/// A Networking client is needed to create an IPSec site connection. If omitted, the
		/// `region` argument of the provider is used. Changing this creates a new
		/// site connection.
		/// </summary>
		public Pulumi.IO<string> Region { get; set; }

		/// <summary>
		/// The owner of the connection. Required if admin wants to
		/// create a connection for another project. Changing this creates a new connection.
		/// </summary>
		public Pulumi.IO<string> TenantId { get; set; }

		/// <summary>
		/// Map of additional options.
		/// </summary>
		public Pulumi.IO<System.Collections.Generic.Dictionary<string, string>> ValueSpecs { get; set; }

		/// <summary>
		/// The ID of the VPN service. Changing this creates a new connection.
		/// </summary>
		public Pulumi.IO<string> VpnserviceId { get; set; }

		public SiteConnection(string name, SiteConnectionArgs args, Pulumi.ResourceOptions opts = default(Pulumi.ResourceOptions))
			: base("openstack:vpnaas/siteConnection:SiteConnection", name, SerialiseArgs(args), opts) {
			AdminStateUp = Outputs["adminStateUp"].Select(item => Protobuf.ToBool(item));
			Description = Outputs["description"].Select(item => Protobuf.ToString(item));
			Dpds = Outputs["dpds"].Select(item => Protobuf.ToList(item, item1 => SiteConnectionDpd.FromProtobuf(item1)));
			IkepolicyId = Outputs["ikepolicyId"].Select(item => Protobuf.ToString(item));
			Initiator = Outputs["initiator"].Select(item => Protobuf.ToString(item));
			IpsecpolicyId = Outputs["ipsecpolicyId"].Select(item => Protobuf.ToString(item));
			LocalEpGroupId = Outputs["localEpGroupId"].Select(item => Protobuf.ToString(item));
			LocalId = Outputs["localId"].Select(item => Protobuf.ToString(item));
			Mtu = Outputs["mtu"].Select(item => Protobuf.ToInt(item));
			Name = Outputs["name"].Select(item => Protobuf.ToString(item));
			PeerAddress = Outputs["peerAddress"].Select(item => Protobuf.ToString(item));
			PeerCidrs = Outputs["peerCidrs"].Select(item => Protobuf.ToList(item, item1 => Protobuf.ToString(item1)));
			PeerEpGroupId = Outputs["peerEpGroupId"].Select(item => Protobuf.ToString(item));
			PeerId = Outputs["peerId"].Select(item => Protobuf.ToString(item));
			Psk = Outputs["psk"].Select(item => Protobuf.ToString(item));
			Region = Outputs["region"].Select(item => Protobuf.ToString(item));
			TenantId = Outputs["tenantId"].Select(item => Protobuf.ToString(item));
			ValueSpecs = Outputs["valueSpecs"].Select(item => Protobuf.ToMap(item));
			VpnserviceId = Outputs["vpnserviceId"].Select(item => Protobuf.ToString(item));
			AdminStateUp = Outputs["adminStateUp"].Select(item => Protobuf.ToBool(item));
			Description = Outputs["description"].Select(item => Protobuf.ToString(item));
			Dpds = Outputs["dpds"].Select(item => Protobuf.ToList(item, item1 => SiteConnectionDpd.FromProtobuf(item1)));
			IkepolicyId = Outputs["ikepolicyId"].Select(item => Protobuf.ToString(item));
			Initiator = Outputs["initiator"].Select(item => Protobuf.ToString(item));
			IpsecpolicyId = Outputs["ipsecpolicyId"].Select(item => Protobuf.ToString(item));
			LocalEpGroupId = Outputs["localEpGroupId"].Select(item => Protobuf.ToString(item));
			LocalId = Outputs["localId"].Select(item => Protobuf.ToString(item));
			Mtu = Outputs["mtu"].Select(item => Protobuf.ToInt(item));
			Name = Outputs["name"].Select(item => Protobuf.ToString(item));
			PeerAddress = Outputs["peerAddress"].Select(item => Protobuf.ToString(item));
			PeerCidrs = Outputs["peerCidrs"].Select(item => Protobuf.ToList(item, item1 => Protobuf.ToString(item1)));
			PeerEpGroupId = Outputs["peerEpGroupId"].Select(item => Protobuf.ToString(item));
			PeerId = Outputs["peerId"].Select(item => Protobuf.ToString(item));
			Psk = Outputs["psk"].Select(item => Protobuf.ToString(item));
			Region = Outputs["region"].Select(item => Protobuf.ToString(item));
			TenantId = Outputs["tenantId"].Select(item => Protobuf.ToString(item));
			ValueSpecs = Outputs["valueSpecs"].Select(item => Protobuf.ToMap(item));
			VpnserviceId = Outputs["vpnserviceId"].Select(item => Protobuf.ToString(item));
		} // ctor

		private static Dictionary<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>> SerialiseArgs(SiteConnectionArgs args) {
			var props = new Dictionary<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>();
			props["adminStateUp"] = Protobuf.ToProtobuf(args.AdminStateUp);
			props["description"] = Protobuf.ToProtobuf(args.Description);
			props["dpds"] = Protobuf.ToProtobuf(args.Dpds, item => Protobuf.ToProtobuf(item));
			props["ikepolicyId"] = Protobuf.ToProtobuf(args.IkepolicyId);
			props["initiator"] = Protobuf.ToProtobuf(args.Initiator);
			props["ipsecpolicyId"] = Protobuf.ToProtobuf(args.IpsecpolicyId);
			props["localEpGroupId"] = Protobuf.ToProtobuf(args.LocalEpGroupId);
			props["localId"] = Protobuf.ToProtobuf(args.LocalId);
			props["mtu"] = Protobuf.ToProtobuf(args.Mtu);
			props["name"] = Protobuf.ToProtobuf(args.Name);
			props["peerAddress"] = Protobuf.ToProtobuf(args.PeerAddress);
			props["peerCidrs"] = Protobuf.ToProtobuf(args.PeerCidrs, item => Protobuf.ToProtobuf(item));
			props["peerEpGroupId"] = Protobuf.ToProtobuf(args.PeerEpGroupId);
			props["peerId"] = Protobuf.ToProtobuf(args.PeerId);
			props["psk"] = Protobuf.ToProtobuf(args.Psk);
			props["region"] = Protobuf.ToProtobuf(args.Region);
			props["tenantId"] = Protobuf.ToProtobuf(args.TenantId);
			props["valueSpecs"] = Protobuf.ToProtobuf(args.ValueSpecs);
			props["vpnserviceId"] = Protobuf.ToProtobuf(args.VpnserviceId);
			return props;
		} // SerialiseArgs

	} // SiteConnection
} // Pulumi.Openstack.Vpnaas
